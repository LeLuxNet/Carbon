/* WARNING!
   This file is automatically generated through scripts/generator.py
   DON'T EDIT IT MANUALLY. ALL CHANGES WILL BE LOST! */

package typing

import "math/big"

func (o Int) Lt(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value.Cmp(other.Value) < 0}, nil
	case Double:
		return Bool{new(big.Float).SetInt(o.Value).Cmp(other.Value) < 0}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value.Cmp(IOne) < 0}, nil
		} else {
			return Bool{o.Value.Sign() < 0}, nil
		}
	}
	return nil, nil
}

func (o Double) Lt(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value.Cmp(new(big.Float).SetInt(other.Value)) < 0}, nil
	case Double:
		return Bool{o.Value.Cmp(other.Value) < 0}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value.Cmp(DOne) < 0}, nil
		} else {
			return Bool{o.Value.Sign() < 0}, nil
		}
	}
	return nil, nil
}

func (o Bool) Lt(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		if o.Value {
			return Bool{1 < other.Value.Cmp(IOne)}, nil
		} else {
			return Bool{0 < other.Value.Sign()}, nil
		}
	case Double:
		if o.Value {
			return Bool{1 < other.Value.Cmp(DOne)}, nil
		} else {
			return Bool{0 < other.Value.Sign()}, nil
		}
	case Bool:
		return Bool{!o.Value && other.Value}, nil
	}
	return nil, nil
}

func (o Int) Le(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value.Cmp(other.Value) <= 0}, nil
	case Double:
		return Bool{new(big.Float).SetInt(o.Value).Cmp(other.Value) <= 0}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value.Cmp(IOne) <= 0}, nil
		} else {
			return Bool{o.Value.Sign() <= 0}, nil
		}
	}
	return nil, nil
}

func (o Double) Le(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value.Cmp(new(big.Float).SetInt(other.Value)) <= 0}, nil
	case Double:
		return Bool{o.Value.Cmp(other.Value) <= 0}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value.Cmp(DOne) <= 0}, nil
		} else {
			return Bool{o.Value.Sign() <= 0}, nil
		}
	}
	return nil, nil
}

func (o Bool) Le(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		if o.Value {
			return Bool{1 <= other.Value.Cmp(IOne)}, nil
		} else {
			return Bool{0 <= other.Value.Sign()}, nil
		}
	case Double:
		if o.Value {
			return Bool{1 <= other.Value.Cmp(DOne)}, nil
		} else {
			return Bool{0 <= other.Value.Sign()}, nil
		}
	case Bool:
		return Bool{!o.Value || other.Value}, nil
	}
	return nil, nil
}

func (o Int) Gt(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value.Cmp(other.Value) > 0}, nil
	case Double:
		return Bool{new(big.Float).SetInt(o.Value).Cmp(other.Value) > 0}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value.Cmp(IOne) > 0}, nil
		} else {
			return Bool{o.Value.Sign() > 0}, nil
		}
	}
	return nil, nil
}

func (o Double) Gt(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value.Cmp(new(big.Float).SetInt(other.Value)) > 0}, nil
	case Double:
		return Bool{o.Value.Cmp(other.Value) > 0}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value.Cmp(DOne) > 0}, nil
		} else {
			return Bool{o.Value.Sign() > 0}, nil
		}
	}
	return nil, nil
}

func (o Bool) Gt(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		if o.Value {
			return Bool{1 > other.Value.Cmp(IOne)}, nil
		} else {
			return Bool{0 > other.Value.Sign()}, nil
		}
	case Double:
		if o.Value {
			return Bool{1 > other.Value.Cmp(DOne)}, nil
		} else {
			return Bool{0 > other.Value.Sign()}, nil
		}
	case Bool:
		return Bool{o.Value && !other.Value}, nil
	}
	return nil, nil
}

func (o Int) Ge(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value.Cmp(other.Value) >= 0}, nil
	case Double:
		return Bool{new(big.Float).SetInt(o.Value).Cmp(other.Value) >= 0}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value.Cmp(IOne) >= 0}, nil
		} else {
			return Bool{o.Value.Sign() >= 0}, nil
		}
	}
	return nil, nil
}

func (o Double) Ge(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value.Cmp(new(big.Float).SetInt(other.Value)) >= 0}, nil
	case Double:
		return Bool{o.Value.Cmp(other.Value) >= 0}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value.Cmp(DOne) >= 0}, nil
		} else {
			return Bool{o.Value.Sign() >= 0}, nil
		}
	}
	return nil, nil
}

func (o Bool) Ge(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		if o.Value {
			return Bool{1 >= other.Value.Cmp(IOne)}, nil
		} else {
			return Bool{0 >= other.Value.Sign()}, nil
		}
	case Double:
		if o.Value {
			return Bool{1 >= other.Value.Cmp(DOne)}, nil
		} else {
			return Bool{0 >= other.Value.Sign()}, nil
		}
	case Bool:
		return Bool{o.Value || !other.Value}, nil
	}
	return nil, nil
}
