/* WARNING!
   This file is automatically generated through scripts/generator.py
   DON'T EDIT IT MANUALLY. ALL CHANGES WILL BE LOST! */

package typing

func (o Int) Lt(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value < other.Value}, nil
	case Double:
		return Bool{float64(o.Value) < other.Value}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value < 1}, nil
		} else {
			return Bool{o.Value < 0}, nil
		}
	}
	return nil, nil
}

func (o Double) Lt(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value < float64(other.Value)}, nil
	case Double:
		return Bool{o.Value < other.Value}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value < 1}, nil
		} else {
			return Bool{o.Value < 0}, nil
		}
	}
	return nil, nil
}

func (o Bool) Lt(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
	case Double:
		if o.Value {
			return Bool{1 < other.Value}, nil
		} else {
			return Bool{0 < other.Value}, nil
		}
	case Bool:
		return Bool{!o.Value && other.Value}, nil
	}
	return nil, nil
}

func (o Int) Le(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value <= other.Value}, nil
	case Double:
		return Bool{float64(o.Value) <= other.Value}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value <= 1}, nil
		} else {
			return Bool{o.Value <= 0}, nil
		}
	}
	return nil, nil
}

func (o Double) Le(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value <= float64(other.Value)}, nil
	case Double:
		return Bool{o.Value <= other.Value}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value <= 1}, nil
		} else {
			return Bool{o.Value <= 0}, nil
		}
	}
	return nil, nil
}

func (o Bool) Le(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
	case Double:
		if o.Value {
			return Bool{1 <= other.Value}, nil
		} else {
			return Bool{0 <= other.Value}, nil
		}
	case Bool:
		return Bool{!o.Value || other.Value}, nil
	}
	return nil, nil
}

func (o Int) Gt(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value > other.Value}, nil
	case Double:
		return Bool{float64(o.Value) > other.Value}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value > 1}, nil
		} else {
			return Bool{o.Value > 0}, nil
		}
	}
	return nil, nil
}

func (o Double) Gt(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value > float64(other.Value)}, nil
	case Double:
		return Bool{o.Value > other.Value}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value > 1}, nil
		} else {
			return Bool{o.Value > 0}, nil
		}
	}
	return nil, nil
}

func (o Bool) Gt(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
	case Double:
		if o.Value {
			return Bool{1 > other.Value}, nil
		} else {
			return Bool{0 > other.Value}, nil
		}
	case Bool:
		return Bool{o.Value && !other.Value}, nil
	}
	return nil, nil
}

func (o Int) Ge(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value >= other.Value}, nil
	case Double:
		return Bool{float64(o.Value) >= other.Value}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value >= 1}, nil
		} else {
			return Bool{o.Value >= 0}, nil
		}
	}
	return nil, nil
}

func (o Double) Ge(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
		return Bool{o.Value >= float64(other.Value)}, nil
	case Double:
		return Bool{o.Value >= other.Value}, nil
	case Bool:
		if other.Value {
			return Bool{o.Value >= 1}, nil
		} else {
			return Bool{o.Value >= 0}, nil
		}
	}
	return nil, nil
}

func (o Bool) Ge(other Object) (Object, Object) {
	switch other := other.(type) {
	case Int:
	case Double:
		if o.Value {
			return Bool{1 >= other.Value}, nil
		} else {
			return Bool{0 >= other.Value}, nil
		}
	case Bool:
		return Bool{o.Value || !other.Value}, nil
	}
	return nil, nil
}
