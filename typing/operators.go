/* WARNING!
   This file is automatically generated through scripts/generator.py
   DON'T EDIT IT MANUALLY. ALL CHANGES WILL BE LOST! */

package typing

type Addable interface {
	Add(Object, bool) (Object, Object)
}

func Add(a, b Object) (Object, Throwable) {
	if a, ok := a.(Addable); ok {
		res, err := a.Add(b, true)
		if err != nil {
			return nil, Throw{Data: err}
		}
		if res != nil {
			return res, nil
		}
	}
	if b, ok := b.(Addable); ok {
		res, err := b.Add(a, false)
		if err != nil {
			return nil, Throw{Data: err}
		}
		return res, nil
	}
	return nil, nil
}

type Subable interface {
	Sub(Object, bool) (Object, Object)
}

func Sub(a, b Object) (Object, Throwable) {
	if a, ok := a.(Subable); ok {
		res, err := a.Sub(b, true)
		if err != nil {
			return nil, Throw{Data: err}
		}
		if res != nil {
			return res, nil
		}
	}
	if b, ok := b.(Subable); ok {
		res, err := b.Sub(a, false)
		if err != nil {
			return nil, Throw{Data: err}
		}
		return res, nil
	}
	return nil, nil
}

type Mulable interface {
	Mul(Object, bool) (Object, Object)
}

func Mul(a, b Object) (Object, Throwable) {
	if a, ok := a.(Mulable); ok {
		res, err := a.Mul(b, true)
		if err != nil {
			return nil, Throw{Data: err}
		}
		if res != nil {
			return res, nil
		}
	}
	if b, ok := b.(Mulable); ok {
		res, err := b.Mul(a, false)
		if err != nil {
			return nil, Throw{Data: err}
		}
		return res, nil
	}
	return nil, nil
}

type Divable interface {
	Div(Object, bool) (Object, Object)
}

func Div(a, b Object) (Object, Throwable) {
	if a, ok := a.(Divable); ok {
		res, err := a.Div(b, true)
		if err != nil {
			return nil, Throw{Data: err}
		}
		if res != nil {
			return res, nil
		}
	}
	if b, ok := b.(Divable); ok {
		res, err := b.Div(a, false)
		if err != nil {
			return nil, Throw{Data: err}
		}
		return res, nil
	}
	return nil, nil
}

type Modable interface {
	Mod(Object, bool) (Object, Object)
}

func Mod(a, b Object) (Object, Throwable) {
	if a, ok := a.(Modable); ok {
		res, err := a.Mod(b, true)
		if err != nil {
			return nil, Throw{Data: err}
		}
		if res != nil {
			return res, nil
		}
	}
	if b, ok := b.(Modable); ok {
		res, err := b.Mod(a, false)
		if err != nil {
			return nil, Throw{Data: err}
		}
		return res, nil
	}
	return nil, nil
}

type Powable interface {
	Pow(Object, bool) (Object, Object)
}

func Pow(a, b Object) (Object, Throwable) {
	if a, ok := a.(Powable); ok {
		res, err := a.Pow(b, true)
		if err != nil {
			return nil, Throw{Data: err}
		}
		if res != nil {
			return res, nil
		}
	}
	if b, ok := b.(Powable); ok {
		res, err := b.Pow(a, false)
		if err != nil {
			return nil, Throw{Data: err}
		}
		return res, nil
	}
	return nil, nil
}

type Negable interface {
	Neg() Object
}
